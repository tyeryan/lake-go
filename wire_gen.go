// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
	"context"
	"github.com/tyeryan/l-common-util/apm"
	"github.com/tyeryan/l-common-util/cache"
	"github.com/tyeryan/l-common-util/config"
	"lake-go/filter"
	"lake-go/grpcclient"
	"lake-go/handler/auth"
	"lake-go/router"
	"net/http"
)

// Injectors from inject_service.go:

func injectRoutes(ctx context.Context) (http.Handler, error) {
	decoderConfigOption := config.ProvideDecodeOption(ctx)
	configStore := config.ProvideConfigStoreImpl(ctx, decoderConfigOption)
	lAuthConfig, err := grpcclient.ProvideLAuthConfig(ctx, configStore)
	if err != nil {
		return nil, err
	}
	lAuthClient, err := grpcclient.ProvideLAuthClient(ctx, lAuthConfig)
	if err != nil {
		return nil, err
	}
	redisConfig, err := cache.ProvideRedisConfig(ctx, configStore)
	if err != nil {
		return nil, err
	}
	clusterClient, err := cache.ProvideRedisClient(ctx, redisConfig)
	if err != nil {
		return nil, err
	}
	distributedCache, err := cache.ProvideCacheClient(ctx, clusterClient, redisConfig)
	if err != nil {
		return nil, err
	}
	authFilter, err := filter.ProvideAuthFilter(ctx, lAuthClient, distributedCache)
	if err != nil {
		return nil, err
	}
	lakeHandler := router.ProvideLakeHandler()
	authHandler, err := auth.ProvideAuthHandler(ctx, lAuthClient)
	if err != nil {
		return nil, err
	}
	apmConfig, err := apm.ProvideApmConfig(ctx, configStore)
	if err != nil {
		return nil, err
	}
	accessLogFilter := filter.ProvideAccessLogFilter(apmConfig)
	handler := router.ProvideRoutes(authFilter, lakeHandler, authHandler, apmConfig, accessLogFilter)
	return handler, nil
}
